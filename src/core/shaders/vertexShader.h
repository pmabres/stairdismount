static const char* gVertexShader =
//    "#version 120\n"
//    "attribute vec3 vertexPosition_modelspace;\n"
//    "attribute vec2 vertexUV;\n"
//    "varying vec2 UV;\n"
//    "uniform mat4 MVP;\n"
//    "void main(){\n"
//    "   gl_Position =  MVP * vec4(vertexPosition_modelspace,1);\n"
//    "   UV = vertexUV;\n"
//    "}\n";
"#version 120\n"
"attribute vec3 vertexPosition_modelspace;\n"
"attribute vec2 vertexUV;\n"
"attribute vec3 vertexNormal_modelspace;\n"
"varying vec2 UV;\n"
"varying vec3 Position_worldspace;\n"
"varying vec3 Normal_cameraspace;\n"
"varying vec3 EyeDirection_cameraspace;\n"
"varying vec3 LightDirection_cameraspace;\n"
"uniform mat4 MVP;\n"
"uniform mat4 V;\n"
"uniform mat4 M;\n"
"uniform vec3 LightPosition_worldspace;\n"
"\n"
"void main(){\n"
"    gl_Position =  MVP * vec4(vertexPosition_modelspace,1);\n"
"    Position_worldspace = (M * vec4(vertexPosition_modelspace,1)).xyz;\n"
"    vec3 vertexPosition_cameraspace = ( V * M * vec4(vertexPosition_modelspace,1)).xyz;\n"
"    EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;\n"
"    vec3 LightPosition_cameraspace = ( V * vec4(LightPosition_worldspace,1)).xyz;\n"
"    LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;\n"
"    Normal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz;\n"
"    UV = vertexUV;\n"
"}\n";